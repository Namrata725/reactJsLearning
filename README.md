# React Project Setup with Vite

## Overview - React

React is a JavaScript library for building user interfaces, especially single-page applications where you need a fast, interactive experience. It lets you build reusable UI components and manage state efficiently.

## Why React

- Component-based architecture
- Fast and efficient rendering with virtual DOM
- Large community and ecosystem
- Suitable for complex frontend applications

## Overview - Vite

Vite is a modern frontend build tool that provides a faster and leaner development experience for modern web projects. It uses native ES modules and starts the server instantly.

## Why Vite

- Lightning-fast cold starts
- Hot Module Replacement (HMR) for instant updates
- Optimized build using Rollup
- Easy configuration for React and other frameworks

## Getting Started

### Installation of Node.js and npm

Install Node.js (which comes with npm) from the official site:

`https://nodejs.org/`

## Why install Node.js and npm?

- **Node.js** is required to run JavaScript tools on your system.
- **npm (Node Package Manager)** is used to manage project dependencies like React, Vite, etc.

## Getting Started with React + Vite

Open your terminal and run:

```bash
npm create vite@latest my-react-app -- --template react
cd my-react-app
npm install
npm run dev
```

---

# React + Vite Project Overview

This project is built using React.js and Vite.

## Folder & File Purpose

### node_modules/

- Automatically generated by npm.
- Contains all installed project dependencies.

### public/

- Stores static files that are directly served (like `favicon`, `robots.txt`).
- Not processed by Vite or React.

### src/

- Main source code folder for the React app.

#### src/assets/

- Stores static assets like CSS, images, or fonts used in the app.

#### App.jsx

- Main component that holds the structure of your application.

#### App.css

- Styles specifically for the `App.jsx` component.

#### index.css

- Global styles applied throughout the app.

#### main.jsx

- Entry point of the React app.
- Renders the `App` component into the DOM.

---

### index.html

- Main HTML file served to the browser.
- React is mounted inside the `<div id="root"></div>`.

### vite.config.js

- Configuration file for Vite (e.g., aliases, plugins, server settings).

### package.json

- Lists project metadata, scripts, and dependencies.

### package-lock.json

- Auto-generated to lock dependency versions.

### .gitignore

- Specifies which files/folders Git should ignore.

### eslint.config.js

- Contains rules and configuration for linting JavaScript/JSX code.

### README.md

- This documentation file explaining the purpose of each part of the project.

---

## My First React Code

Once the project is set up, replace the content of `src/App.jsx` with the following code:

```jsx
function App() {
  return (
    <div>
      <h1>Hello World</h1>
      <h2>This is my first React App</h2>
      <p>My name is namrata...</p>
    </div>
  );
}

export default App;
```

## What is a Component in React?

A **component** in React is a **reusable piece of UI**. It works like a JavaScript function but returns JSX (HTML-like code).

```jsx
function Welcome() {
  return <h1>Hello, Namrata!</h1>;
}
```

---

## How to Use a Component

To use a component, call it like an HTML tag inside JSX:

```jsx
function App() {
  return (
    <div>
      <Welcome />
    </div>
  );
}

function Welcome() {
  return <h1>Hello, Namrata!</h1>;
}
```

> Component names must start with an uppercase letter.

---

## Difference Between a Component and a Function

| Aspect          | Function                          | Component                   |
| --------------- | --------------------------------- | --------------------------- |
| Purpose         | Performs logic and returns values | Returns JSX (UI)            |
| Return Type     | Numbers, strings, etc.            | JSX (HTML-like structure)   |
| Naming          | Can be lowercase                  | Must start with uppercase   |
| React-specific? | No                                | Yes                         |
| Used in JSX     | No                                | Yes, like `<MyComponent />` |

### Example:

#### file name:Header.jsx

- since we are using component in new file so we have to import file in App.jsx :import Header from "./Header.JSX" and call inside App component :

---

```jsx

function Header() {
  return (
    <div>
      <h3>header</h3>
      <h3>{greet()}</h3>
    </div>
  );
}

function greet() {
  return "Hello from greet function!";
}

export default Header;

App.jsx

import Header from "./Header";
function App() {
  return (
    <div>
      <Header />
    </div>
  );
}

export default App;
```

---

# Understanding JSX in React

JSX (JavaScript XML) is a **syntax extension** for JavaScript used in React. It allows you to write HTML-like code directly inside JavaScript, making it easier to create React elements.

---

## What is JSX?

JSX lets you write UI in a syntax similar to HTML, but with the full power of JavaScript.

- You can embed expressions inside `{}`
- It’s not mandatory, but it's widely used in React for simplicity and clarity
- JSX is **compiled into `React.createElement()`** behind the scenes

---

### 1. User Variable

Embed variables inside JSX:

```jsx
function MyName() {
  const name = "World";
  return <h4>Hello {name}!</h4>;
}
```

---

### 2. User function

```jsx
function sub(a, b) {
  // function
  return (
    <div>
      <h4>
        a - b= {a} - {b}= {a - b}
      </h4>
    </div>
  );
}
```

---

### 3. User condition

```jsx
function ValidAge() {
  const age = 25;
  if (age >= 18) return <h4>You are an adult</h4>; //condition inside JSX curly braces
  return <h4>You are a minor</h4>;
}
```

---

### 4.Operation

```jsx
function operation(a, b, op) {
  if (op === "+") return a + b;
  if (op === "-") return a - b;
  if (op === "*") return a * b;
  if (op === "/") return a / b;

  function sub(a, b) {
    // function
    return (
      <div>
        <h4>
          a - b= {a} - {b}= {a - b}
        </h4>
      </div>
    );
  }
}

// Usage:
<h4>Result = {operation(12, 3, "/")}</h4>;
```

---

### 5. Object and Array

```jsx
function MyObject() {
  const person = {
    name: "Namrata",
    age: 25,
    city: "Kathmandu",
  };
  return (
    <h4>
      {person.name} is {person.age} years old and lives in {person.city}
    </h4>
  ); //calling object inside JSX curly braces
}

function MyArray() {
  const fruits = ["apple", "banana", "cherry"];
  return <h4>{fruits[0]} is the first fruit</h4>; //calling array inside JSX curly braces
}
```

---

### 6.HTML Tags

```jsx
const path = "https://m.media-amazon.com/images/I/714d2f9gQGL.jpg";

<img src={path} alt="Example" style={{ width: "200px", height: "200px" }} />;
```

#### create file and export it then import to Appp : file name: JSXCurlyBraces.

---

## BtnClick React Component

This is a simple React component that demonstrates:

- JavaScript vs. React functions
- Handling button clicks
- Using arrow functions
- Passing parameters to functions in `onClick` events

---

## Topics Covered

### 1. Difference Between JavaScript Function and React Function

| JavaScript Function            | React Function (Component)        |
| ------------------------------ | --------------------------------- |
| Can exist anywhere in JS files | Specifically used for UI in React |
| Returns any value              | Returns JSX                       |
| Used for logic or utilities    | Used to define components         |
| `function greet() {}`          | `function MyComponent() {}`       |

---

### 2. Steps

#### Step 1: Make a Function

```js
function handleClick1() {
  alert("Button clicked!");
}
```

#### Step 2: Make a Button

<button onClick={handleClick1}>Click Me</button>

#### Step 3: Call an Arrow Function

```js
const handleClick2 = () => {
  alert("Arrow function clicked!");
};
```

#### Step 4: Pass Parameters to a Function

```js
const fruit = (name) => {
  alert(name);
};

<button onClick={() => fruit("apple")}>Apple</button>
<button onClick={() => fruit("banana")}>Banana</button>
```

---

### file name: ClickHandler.jsx.

---

# Understanding state in React

## what is state in React JS ?

State is a container to store data like variable. State is mutable and dynamic . we have to import it when we want to use it. It re-render component automatically so that data can visible on UI.

## what is hooks in React JS?

Hooks are the special feature for function component . hooks let you use different feature from your components. Eg: state , life cycle moment , side effect etc

### example

```jsx
import { useState } from "react";

function UseState() {
  const [fruit, setValue] = useState("apple");
  const btnClick = () => {
    if (fruit === "apple") {
      setValue("banana");
    } else {
      setValue("apple");
    }
  };

  return (
    <div>
      <h1>UseState Example</h1>
      <p>Current fruit: {fruit}</p>
      <button onClick={btnClick}>Change Fruit</button>
    </div>
  );
}

export default UseState;
```

## Toggle or Hide and show in React JS

### steps

- define state
- update state on btn click
- add condition for toggle
- hide and show component

### What Are Props?

In React, **props** (short for **properties**) are a way to pass **data from a parent component to a child component**. They make components dynamic and reusable by allowing them to receive different values.

Props are **read-only**, meaning a component cannot modify the props it receives — it can only use or display them.

---

## Components in This Project

### 1. `UserComponent`

**Purpose**: Acts as the central component that organizes and manages the data being passed to other components.

- It receives various types of props from its parent (`Props.jsx`), such as:
  - Simple variables (`name`, `age`)
  - Objects (`user`, `user2`)
  - An array (`country`)
  - State and state updater function (`student`, `setStudent`)
- It then delegates and passes these props to the appropriate child components (`VariableProps`, `ObjectProps`, `ArrayProps`, and `ClickProps`) for display or interaction.
- It also handles a **click event** to prompt the user for input, updates the state with `setStudent`, and conditionally renders the `ClickProps` component with the new value.

---

### 2. `VariableProps`

**Purpose**: Simple data types like `name` and `age` are passed as individual props to show how primitive values can be rendered in child components (`VariableProps`).

```jsx
<VariableProps name={name} age={age} />
```

**Data type**: Variable (string, number)

**Display**: Shows a welcome message using `name` and `age`.

---

### 3. `ObjectProps`

**Purpose**: Complex data structures like user details (`user`, `user2`) are passed to demonstrate how you can access nested properties inside components (`ObjectProps`).

```jsx
<ObjectProps user={user} user2={user2} />
```

**Data type**: Object

**Display**: Displays properties like `name`, `age`, and `email` from each object.

---

### 4. `ArrayProps`

**Purpose**: A list of country names is passed as an array to show how to iterate over arrays using `.map()` and render each item (`ArrayProps`).

```jsx
<ArrayProps country={country} />
```

**Data type**: Array

**Display**: Uses `.map()` to loop through the array and render a `<li>` for each country.

---

### 5. `ClickProps`

**Purpose**: Demonstrates how to update and pass props through user interaction (click event).

```jsx
<ClickProps student={student} />
```

- A prompt appears when clicking the button.
- The entered name is saved to state and passed as a prop to be displayed.

---

## More About Props in React

This project demonstrates advanced usage of props in React by covering:

- **Default Props**: Provide fallback values to props.
- **Passing JSX using `children`**: Compose reusable layouts.
- **Changing Styles Dynamically with Props**: Make components flexible and customizable.

## Components Overview

### Default Props

In React, you can assign default values directly in the function parameter. This prevents `undefined` issues when props are not passed.

```jsx
function MoreProps({ name = "New User" }) {
  return <p>Name: {name}</p>;
}
```

Even if `name` isn't passed, `"New User"` will be shown.

---

### Passing JSX using `children`

Props in React can contain JSX by using the `children` prop. This allows you to reuse layout components and inject different content inside.

```jsx
<Wrapper>
  <p>Wrapper no: 1</p>
</Wrapper>

<Wrapper>
  <p>Wrapper no: 2</p>
  <h4>Register Please</h4>
</Wrapper>
```

In the `Wrapper` component, `children` automatically represents the content between its opening and closing tags.

```jsx
function Wrapper({ children }) {
  return <div>{children}</div>;
}
```

---

### Changing Styles Dynamically with Props

You can make components highly customizable by using props for styling.

```jsx
function Wrapper({ children, color = "orange" }) {
  return <div style={{ color: color }}>{children}</div>;
}
```

When you pass the `color` prop, it overrides the default color:

```jsx
<Wrapper color="green">
  <p>This text will be green</p>
</Wrapper>
```

## example code: MoreProps.jsx

---

## GetInputField Component

A simple **React functional component** that demonstrates how to handle user input using the `useState` hook. It allows users to enter text, display it below the input field, and clear the input with a button.

### Code Example

```jsx
import { useState } from "react";

function GetInputField() {
  const [name, setName] = useState("");

  const changeName = (event) => {
    setName(event.target.value);
  };

  const handleClear = () => {
    setName("");
  };

  return (
    <div>
      <h1>user</h1>
      <input
        type="text"
        placeholder="Name"
        onChange={changeName}
        value={name}
      />
      <h4>{name}</h4>
      <button onClick={handleClear}>Clear all</button>
    </div>
  );
}

export default GetInputField;
```

### explaination

- **State Management:**
- The component uses `useState` to hold the `name` value.
- **Event Handling:**
  - The `changeName` function updates the `name` state when the user types into the input field.
  - The `handleClear` function resets the `name` state to an empty string when the "Clear all" button is clicked.
- **Rendering:**

  - The input field displays the current value of `name`.
  - The entered name is also displayed below the input field in a `<h4>` tag.
  - The "Clear all" button clears the input field and resets the name to an empty string.

---

## Controlled Component in React

### What is a Controlled Component?

A **controlled component** is a form element (like an input field) whose value is controlled by **React state**. In other words, the value of the input is set and updated by React, making the component predictable and manageable.

### How to Identify a Controlled Component?

A controlled component typically:

- **Stores the input field value in state**.
- **Uses an event handler (like `onChange`) to update state** when the user interacts with the input field.
- **Sets the `value` attribute of the input to the state value**.

### Benefits of Controlled Components

**Single Source of Truth**: All form data lives in React state, making it easy to manage and debug.  
**Validation and Manipulation Before Submit**: Data can be validated, formatted, or transformed in the component itself.  
**Dynamic Updates**: Inputs can respond to state changes instantly (e.g., resetting, conditional rendering).

### Handling Multiple Inputs in State

Each input field is tied to its own state variable. The `onChange` event updates the corresponding state.

```jsx
const [name, setName] = useState("");
const [password, setPassword] = useState("");
const [email, setEmail] = useState("");

<input value={name} onChange={(e) => setName(e.target.value)} />
<input value={password} onChange={(e) => setPassword(e.target.value)} />
<input value={email} onChange={(e) => setEmail(e.target.value)} />
```

### Clear All Input Fields with One Click

To reset all fields, you simply update each state variable back to an empty string.

```jsx
const handleClear = () => {
  setName("");
  setPassword("");
  setEmail("");
};

<button type="button" onClick={handleClear}>
  Clear
</button>;
```

### Example Code: ControlledComponent.jsx

---

## Handle Checkbox in React

This example demonstrates how to manage multiple checkbox selections in React using state. Each time a checkbox is selected or deselected, the state is updated accordingly.

---

### What it Covers

- **Create multiple checkboxes**
- **Define a state variable to track checkbox values**
- **Add checkbox value to state when checked**
- **Remove checkbox value from state when unchecked**

---

### State Setup for Checkboxes

An array is used to store selected skill values.

```jsx
const [skills, setskills] = useState([]);
```

### Event Handler Logic

The HandleCheckboxChange function adds a skill if it's checked and removes it if it's unchecked.

```jsx
const HandleCheckboxChange = (event) => {
  const { value, checked } = event.target;

  if (checked) {
    setskills([...skills, value]); // Add skill
  } else {
    setskills(skills.filter((skill) => skill !== value)); // Remove skill
  }
};
```

### JSX: Render Checkboxes

Each checkbox is linked to the same change handler. The value represents the skill name.

```jsx
<input
  type="checkbox"
  value="JavaScript"
  id="JavaScript"
  onChange={HandleCheckboxChange}
/>
<label htmlFor="JavaScript">JavaScript</label>

```

### Benefits

- Easy tracking of multiple selections.
- Real-time dynamic updates.
- Great for forms with multi-select options.

### Example Code: HandleCheckbox.jsx

---

## Handling Radio Buttons and Dropdown in React

This component demonstrates how to handle **radio buttons** and **dropdown lists** using controlled components in React.

## What It Covers

- Make a radio button group
- Track selected radio button value with state
- Set default selected radio button
- Create a dropdown list
- Track dropdown selection with state
- Set default selected dropdown option

## Radio Button: Gender Selection

- Uses `useState` to store the selected gender.
- Controlled using `checked={gender === "value"}`.
- Updates the gender state via `onChange`.

```jsx
const [gender, setGender] = useState("female");

<input
  type="radio"
  name="gender"
  value="male"
  checked={gender === "male"}
  onChange={(e) => setGender(e.target.value)}
/>
<label>Male</label>

<input
  type="radio"
  name="gender"
  value="female"
  checked={gender === "female"}
  onChange={(e) => setGender(e.target.value)}
/>
<label>Female</label>

```

### Dropdown: City Selection

- Uses useState to track selected city.
- Sets the initial city to Kathmandu using useState("Kathmandu").
- Uses value and onChange to make the dropdown controlled.

```jsx
const [city, setCity] = useState("Kathmandu");

<select value={city} onChange={(e) => setCity(e.target.value)}>
  <option value="Kathmandu">Kathmandu</option>
  <option value="Biratnagar">Biratnagar</option>
  <option value="Pokhara">Pokhara</option>
  <option value="Lalitpur">Lalitpur</option>
  <option value="Bhaktapur">Bhaktapur</option>
</select>;
```

## filename: HandleRadioButtonAndDropdown.jsx

---

## Looping with `map()` Function in React

This example demonstrates how to use JavaScript arrays and React's `map()` function to dynamically render content such as a table.

## What is Covered?

- What is an array?
- How to define an array in React?
- How to create a static HTML table
- How to use the `map()` function for looping and rendering elements in JSX

## What is an Array?

An array is a collection of items stored in a single variable. In JavaScript and React, arrays are commonly used to store lists of data.

```js
const fruits = ["Apple", "Banana", "Cherry", "Date"];
```

### What is an Array of Objects?

An array of objects is a list where each item is an object containing multiple key-value pairs.

```jsx
const fruitsData = [
  { id: 1, name: "Apple", color: "Red", price: 120 },
  { id: 2, name: "Banana", color: "Yellow", price: 50 },
  { id: 3, name: "Cherry", color: "Red", price: 200 },
  { id: 4, name: "Graps", color: "Green", price: 150 },
  { id: 5, name: "Orange", color: "Orange", price: 80 },
];
```

### Static HTML Table Example

```jsx

<table>
  <tr>
    <td>1</td>
    <td>Apple</td>
    <td>Red</td>
    <td>120</td>
  </tr>
  <!-- more rows -->
</table>

```

### Dynamic Table Using .map()

To dynamically render table rows:

```jsx
{
  fruitsData.map((fruit) => (
    <tr key={fruit.id}>
      <td>{fruit.id}</td>
      <td>{fruit.name}</td>
      <td>{fruit.color}</td>
      <td>{fruit.price}</td>
    </tr>
  ));
}
```

### Example Code: LoopingWithMapFunction.jsx

---

## Looping Through Components with Props in React

This example demonstrates how to dynamically render multiple React components using an array of user data. It covers best practices like reusable components, looping with `.map()`, passing props, and adding inline styles.

## What is Covered?

- Create a reusable component
- Use `.map()` function to loop over data in JSX
- Render a component multiple times using loop
- Pass data as props from parent to child
- Apply inline styling for each component

## Key Concepts

### 1. Component-Based Structure

React is built around reusable components. Here, we create a child component named `LoopComponentUser` to display each user's details.

---

### 2. Array of Objects

Data is stored in an array where each item is an object:

```js
{
  Id: 1,
  UserName: "Ram",
  Age: 23,
  email: "ram@example.com"
}
```

### 3. Looping with .map()

To display all users, we use the .map() function and pass each user as a prop to LoopComponentUser.

### example code : LoopComponent.jsx

```jsx
function LoopComponentUser({ user }) {
  return (
    <div
      style={{
        padding: "10px",
        border: "1px solid",
        margin: "10px",
        width: "400px",
        borderRadius: "10px",
      }}
    >
      <p>
        <strong>Id: </strong>
        {user.Id}
      </p>
      <p>
        <strong>Name: </strong>
        {user.UserName}
      </p>
      <p>
        <strong>Age: </strong>
        {user.Age}
      </p>
      <p>
        <strong>Email: </strong>
        {user.email}
      </p>
    </div>
  );
}

export default LoopComponentUser;
```

### filr loop and render users: file: LoopComponent.jsx

```jsx
import LoopComponentUser from "./LoopComponentUser";

function LoopComponent() {
  const Users = [
    { Id: 1, UserName: "Ram", Age: 23, email: "ram@example.com" },
    { Id: 2, UserName: "Teena", Age: 23, email: "teena@example.com" },
    { Id: 3, UserName: "Rahul", Age: 23, email: "rahul@example.com" },
    { Id: 4, UserName: "Muna", Age: 23, email: "muna@example.com" },
    { Id: 5, UserName: "Ranjan", Age: 23, email: "ranjan@example.com" },
  ];

  return (
    <div>
      {Users.map((user) => (
        <div key={user.Id}>
          <LoopComponentUser user={user} />
        </div>
      ))}
    </div>
  );
}

export default LoopComponent;
```

## Nested Looping in React

In this example, we demonstrate how to perform **nested looping** using the `.map()` function in React. This is useful when you have hierarchical or nested data such as a list of schools and their respective students.

## What is Covered?

- Understand array of objects with nested arrays
- Implement **outer loop** to display parent data (Schools)
- Implement **inner loop** to display child data (Students)
- Create reusable **component for outer loop** (`SchoolData`)
- Create reusable **component for inner loop** (Students inside `SchoolData`)
- Use `.map()` for nested structures
- Apply basic inline styling

## Real-World Use Cases

This pattern is very useful in situations like:

- Schools and Students
- Departments and Employees
- Categories and Products

### 1. Array of Objects with Nested Array

```jsx
const SchoolDetails = [
  {
    SclId: 101,
    SclName: "JMC",
    SclCity: "kathmandu",
    studentData: [
      { studId: 1001, studName: "sachin", Grade: 10 },
      { studId: 1002, studName: "deepti", Grade: 6 },
    ],
  },
  // More schools...
];
```

### 2. Outer .map() – Looping Schools

```jsx
{
  SchoolDetails.map((school) => (
    <div key={school.SclId}>
      <SchoolData SchoolDetails={school} />
    </div>
  ));
}
```

### 3. Receiving Props in Child Component

```jsx
function SchoolData({ SchoolDetails }) {
  // use SchoolDetails inside here
}
```

### 4. Inner .map() – Looping Students

```jsx
{
  SchoolDetails.studentData.map((student) => (
    <div key={student.studId}>
      <p>{student.studName}</p>
      <p>{student.Grade}</p>
    </div>
  ));
}
```

## full code : NestedLoopMap.jsx , SchoolData.jsx

---

## React Hooks & useEffect

## what are hooks?

In old version of React i.e older than 16 where developers use call components. IN new versions mostly functional component is use. so to archeive state, life cycle, other features in functional component. we use hooks.

## Why Use Hooks?

Hooks solve common problems like:

- Reusing **stateful logic** without HOCs or render props
- Reducing component **boilerplate**
- Eliminating confusion with `this` in class components
- Writing **cleaner**, more **readable**, and **modular** code

---

## Popular React Hooks

| Hook                | Purpose                                           |
| ------------------- | ------------------------------------------------- |
| `useState()`        | Add local state to a component                    |
| `useEffect()`       | Handle side-effects like API calls, subscriptions |
| `useContext()`      | Access global/shared data                         |
| `useRef()`          | Access DOM or store mutable values                |
| `useReducer()`      | Manage complex state logic                        |
| `useMemo()`         | Cache computed values                             |
| `useCallback()`     | Cache function references                         |
| `useLayoutEffect()` | Like `useEffect`, but fires **before** painting   |

---

## History of Hooks

- **Introduced in:** React v16.8 (Feb 2019)
- **Goal:** Simplify reuse of stateful logic & lifecycle behavior in functional components.

---

## What is a Side Effect?

In React, a **side-effect** is any operation that:

- Interacts with **outside systems** (e.g., API calls, DOM, timers)
- **Updates non-local state** (like global variables or browser storage)
- **Changes something outside React's control**

---

## How to Identify a Hook?

You can easily identify a hook by the following:

- It **always starts with the word `use`**
  ```js
  useState, useEffect, useContext, useCustomHook;
  ```

## Why useEffect?

The useEffect() hook:

- Replaces componentDidMount, componentDidUpdate, and componentWillUnmount
- Used for data fetching, event listeners, timers, subscriptions, etc.
- Optionally cleans up with a return function

## What It Covers

- useState and state updates
- useEffect usage with dependency array
- Function called **only when `counter` changes**
- Preventing unnecessary function calls
- Adding multiple pieces of state (`counter` and `data`)
- Updating different states with buttons

## 1. Declaring State

```jsx
const [counter, setCounter] = useState(0);
const [data, setData] = useState(0);
```

## 2. Updating State

```jsx
function updateCounter() {
  setCounter(counter + 1);
}

function updateData() {
  setData(data + 1);
}
```

## 3.Using useEffect With Dependencies

```jsx
useEffect(() => {
  console.log("counter updated:", counter);
}, [counter]); // Runs only when `counter` changes
```

## 4. 4. Side-effect on Every Render (⚠️ Not Recommended)

```jsx
useEffect(() => {
  console.log("Runs after every render");
});
```

### example code: UseEffectDemo.jsx

---

## Handle Side-Effects **From Props**

This example demonstrates how to **handle side effects caused by props** using React's `useEffect` hook.

### What It Covers

- How to **create reusable components**
- How to **pass props** from parent to child component
- How to **handle side effects** using `useEffect`
- How to use the **dependency array** to control when effects run
- Understanding **which effect triggers on which prop update**

---

## 1. useEffect with empty dependency array:

```jsx
useEffect(() => {
  getCounter();
}, []); // runs only once on mount
```

## 2. useEffect watching only data prop:

```jsx
useEffect(() => {
  dataFunction();
}, [data]); // runs only when `data` prop changes
```

## 3. useEffect watching data and count props:

```jsx
useEffect(() => {
  sayHi();
}, [data, count]); // runs when either `data` or `count` changes
```

## file example code: PropsEffectDemo.jsx , PropsEffectHandler.jsx

---

## What is Component Life Cycle?

A **component life cycle** refers to the different stages a React component goes through from the moment it's created until it is removed from the DOM.

## Life Cycle Linked to Human Life

| Human Life Stage  | Component Life Cycle Phase        |
| ----------------- | --------------------------------- |
| Born              | Mounting (Component is added)     |
| Grows and changes | Updating (Props or State change)  |
| Dies              | Unmounting (Component is removed) |

Just like humans have predictable stages of life, React components follow these stages during their existence in the UI.

## Phases of Component Life Cycle

1. **Mounting**

   - Component is rendered for the first time.
   - `useEffect(() => {}, [])` runs once.

2. **Updating**

   - Component updates due to state or props changes.
   - `useEffect(() => {}, [dependency])` runs when dependency updates.

3. **Unmounting**

   - Component is removed from the UI.
   - Cleanup function inside `useEffect` runs.

## 1. Mounting phase: run once

```jsx
useEffect(() => {
  getCount();
}, []);
```

## 2. Updating phase: run when data changes

```jsx
useEffect(() => {
  dataFunction();
}, [data]);
```

## 3. Unmounting phase: cleanup

```jsx
useEffect(() => {
  return () => {
    console.log("unmount phase");
  };
}, []);
```

### Example Code: `LifeCycleDemo.jsx` , `LifeCycleDemoHandle.jsx`

---

## Styling React UI Using CSS

React provides **multiple ways** to apply styles to components. Each method has its use case depending on the size, structure, and complexity of your application.

## Types of Styling in React.js

- Inline Styling
- External CSS File
- CSS Modules
- Styled Components (via `styled-components` library)
- External CSS Library / Framework (e.g., Bootstrap, Tailwind)

## Inline CSS

- Defined directly inside components using the `style` attribute.
- Uses **JavaScript object syntax** instead of regular CSS strings.
- Property names use **camelCase**, not kebab-case.
- Best for **quick, dynamic, component-scoped styling**.

## How React Inline CSS is Different from HTML Inline Style?

| Feature               | React Inline CSS              | HTML Inline Style               |
| --------------------- | ----------------------------- | ------------------------------- |
| Syntax                | JavaScript Object             | String                          |
| Property Naming       | camelCase (`backgroundColor`) | kebab-case (`background-color`) |
| Dynamic Value Support | Yes                           | No                              |
| Media Query Support   | No                            | No                              |

## Example Code: `InlineCssDemo.jsx`

```jsx
<h2 style={{ color: "red", textAlign: "center" }}>InlineCssDemo</h2>
```

---

## React Dynamic & Conditional Inline CSS

### What This Demo Covers

- **Dynamic and Conditional Inline CSS** using React.
- How to use `useState` for **style objects**.
- Creating **buttons to update styles dynamically**.
- **Changing theme and layout** on button click (like background color and text color).
- Conditionally rendering layout using a boolean flag.

## Key Concepts

### 1. **Dynamic and Conditional Inline CSS**

React allows dynamic inline styling using JavaScript object syntax, which supports conditions and user-triggered updates.

### 2. **Using `useState` to Manage Style Objects**

```jsx
const [styleCard, setCrdStyle] = useState({
  boxShadow: "5px 5px 5px 5px",
  margin: "20px",
  padding: "10px",
  width: "350px",
});
```

### 3. **Updating Styles on Button Click**

You can update styles dynamically with functions that change state:

```jsx
const updateTheme = (bg, textColor) => {
  setCrdStyle({ ...styleCard, backgroundColor: bg });
  setColor(textColor);
};
```

### 4. **Toggle Layout or Style Conditionally**

```jsx
const [grid, setGrid] = useState(true);

<button onClick={() => setGrid(!grid)}>Toggle Grid</button>

<div style={{ display: grid ? "flex" : "block" }}>
  {/* Cards */}
</div>
```

### example code: DynamicCSSDemo

---

## External CSS in React

This demo shows how to apply **External CSS** styling in a React component using a separate CSS file.

## What It Covers

- What is External CSS
- How to write External CSS
- Creating a separate `.css` file
- Writing styles in that file
- Correct way to import and apply external CSS in React

## How to Use External CSS in React

### 1. Create a CSS File

Create a file named (for example) `ExternalCSSDemo.css` in the same directory as your component.

### 2. Import CSS File into React Component

```js
import "./ExternalCSSDemo.css";
```

### 3. Use Class Names

Apply the styles using the `className` attribute in JSX:

```jsx
<h2 className="heading">External Style</h2>
<img className="img-style" src="..." alt="" />
```

## Benefits

- Cleaner JSX structure
- Easy to maintain and update styles
- Reusable across components
- Helps follow best practices and separation of concerns

## file name :ExternalCSSDemo.jsx

---

# CSS Modules in React

## What is CSS Module?

CSS Modules is a styling approach in React that allows you to write CSS that's scoped **locally to the component**, rather than globally. This prevents style conflicts across components and helps manage large codebases more efficiently.

---

## Why We Need CSS Modules

In large applications, global CSS class names can easily conflict. CSS Modules help by **scoping styles locally to the component**. This ensures styles don’t clash or leak across components.

## Benefits

- Locally scoped styles (no class name collisions)
- Cleaner and modular codebase
- Easier maintenance in large projects

## How to Use CSS Modules

### 1. Create a CSS Module File

A CSS Module file **must end with `.module.css`**
`cssModuleDemo.module.css`

```css
.heading {
  color: green;
}

.img {
  width: 350px;
}

...
```

### 2. Import the CSS Module in Component

```jsx
import style from "./CSS/cssModuleDemo.module.css";

function CssModuleDemo() {
  return (
    <div>
      <div className={style.mainCard}>
        <img
          src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQbFy8dYBao7j3VKvPdgSEvn1Vly2z_02kBbQ&s"
          alt="cherry tree"
          className={style.img}
        />

        <div className={style.textDiv}>
          <h4 className={style.heading}>Cherry Tree</h4>
        </div>
      </div>
    </div>
  );
}

export default CssModuleDemo;
```

---

## style Component

### what is styled component?

**Styled-components** is a library for styling React components using a special syntax called **Tagged Template Literals**. It allows you to write actual CSS code within your JavaScript, scoped to individual components.

### Benefits:

- No class name bugs
- Automatic critical CSS
- Easier maintenance of styles
- Scoped styles by default

## Install Styled-Components

To install the `styled-components` package, use the following command:

```
npm install styled-components
```

To confirm the installation, check `package.json` for an entry like:

```json
"styled-components": "^x.x.x"
```

## How to Use Styled Components

1. **Import styled-components**:

   ```js
   import styled from "styled-components";
   ```

2. **Create styled elements** (two ways):

   - **Using JavaScript object syntax:**

     ```js
     const Heading = styled.h1({
       color: "blue",
       border: "1px solid blue",
       padding: "10px",
     });
     ```

   - **Using Tagged Template Literals:**
     ```js
     const StyleBtn = styled.button`
       color: red;
       width: 130px;
       height: 40px;
       margin: 20px;
       font-size: 20px;
     `;
     ```

3. **Use the styled elements in JSX**.

## Example Code: StyleComponentDemo.jsx

---

## Add Bootstrap in React

### What is Bootstrap?

Bootstrap is a popular **open-source CSS framework** for building responsive and mobile-first websites. It includes design templates for typography, forms, buttons, navigation, and other UI components using both CSS and JavaScript.

## Why Use Bootstrap in React?

- Pre-built UI components
- Responsive and mobile-first
- Clean design with minimal effort
- Easy customization using classNames or variant props

### What This Covers

- What is Bootstrap
- How to install Bootstrap and React-Bootstrap
- How to import Bootstrap into your React app
- Using Bootstrap UI components: Button, Alert, Navbar

### How to Install Bootstrap in React

Use the following command in your terminal to install both **Bootstrap** and **React-Bootstrap**:

```bash
npm install react-bootstrap bootstrap
```

After installation, confirm the presence of both packages in your package.json.

### How to Import Bootstrap CSS

Import the Bootstrap stylesheet in your main entry file (e.g., main.jsx or index.js) for global styles:

```jsx
import "bootstrap/dist/css/bootstrap.min.css";
```

This line ensures Bootstrap styles are available throughout your app.

## Bootstrap Component Example :BootstrapDemo.jsx

---

## What is useRef?

`useRef` is a **React Hook** that provides a way to reference **DOM elements** or **persist values** across renders **without triggering re-renders**. Commonly used to directly interact with DOM elements or to store mutable values.

## What It Covers

- Managing **uncontrolled components**.
- Directly **accessing DOM elements** (e.g., input fields).
- Performing operations such as:
  - Setting focus
  - Modifying styles
  - Toggling visibility
- No component re-render occurs when the `ref` value changes.

## Step 1: Create a reference

const inputRef = useRef(null);

## Step 2: Attach it to an element

<input ref={inputRef} />

## Step 3: Use it to manipulate the DOM directly

inputRef.current.focus(); // focuses the input
inputRef.current.style.color = "green"; // changes text color
inputRef.current.style.display = "none"; // hides the input
inputRef.current.style.display = "inline"; // shows the input

## fileName: UseRefDemo.jsx

---

## Uncontrolled Component and `useRef` Demo

This section demonstrates how to handle forms in React without using `useState`. It covers both the traditional DOM-based approach and the modern React `useRef` method.

## What It Covers

- What is an Uncontrolled Component?
- Using `document.querySelector` to access input values
- Using `useRef` to access and control DOM elements
- Preventing unnecessary re-renders while accessing form data

## What is an Uncontrolled Component?

An **uncontrolled component** in React is a form element (like `<input>`, `<textarea>`, etc.) where the value is not controlled by React state. Instead, you **let the browser handle it**, and you access its value when needed, typically on form submission.

Instead of managing value with `useState`, you use:

- DOM methods like `document.querySelector`
- React's `useRef` hook

## Why Use useRef Instead of State?

- useRef does not trigger re-render when updated.
- Great for direct DOM manipulation like focusing inputs, getting values, or animations.
- Ideal for simple forms where managing state isn't necessary.

```js
// Accessing values using document.querySelector (DOM-based)
const user = document.querySelector("#name").value;
const password = document.querySelector("#password").value;

// Accessing values using useRef (React-based)
const user = userRef.current.value;
const password = passwordRef.current.value;
```

## Full Example Code – Uncontrolled.jsx

---

# Passing Function as Props in React

## What It Covers

- What is **passing function as props** in React?
- Why do we need to pass function as props?
- How to create **parent and child components**
- How to **call a parent function from a child** using props

## Explanation

In React, **functions can be passed as props** from a parent component to a child component. This allows the child component to communicate or trigger behavior in the parent component. It's a common pattern to handle events or data flow from children back to the parent.

## Important Code Chunk

### Parent Logic

```js
const displayName = (name) => {
  alert(name);
};

const getFunction = () => {
  alert("function user called");
};

<FunctionPropsUser
  displayName={displayName}
  name="aa"
  getFunction={getFunction}
/>;
```

- displayName and getFunction are declared in the parent.
- Passed as props to the child component.

### Child Logic

```jsx
function FunctionPropsUser({ displayName, name, getFunction }) {
  return (
    <>
      <button onClick={() => displayName(name)}>User Display!!</button>
      <button onClick={getFunction}>get function</button>
    </>
  );
}
```

- Props are destructured and executed directly in the child on button click.
- The child calls the parent-defined functions with or without arguments.

## Parent Component Example : File: functionProps.jsx

## Child Component Example : File: FunctionPropsUser.jsx

---

## What is `forwardRef`?

`forwardRef` is a React API used to forward a `ref` from a parent component to a child component. This is useful when the parent needs to directly interact with a DOM element inside the child component.

---

### `ForwardRefDemo.jsx`

```jsx
import { useRef } from "react";
import ForwardRefUser from "./ForwardRefUser";

function ForwardRefDemo() {
  const inputRef = useRef(null);

  const updateInput = () => {
    inputRef.current.value = 1000;
    inputRef.current.focus();
  };

  return (
    <div>
      <h1>App</h1>
      <h4>Forward ref</h4>
      <User ref={inputRef} />
      <button onClick={updateInput}>Update input</button>
    </div>
  );
}

export default ForwardRefDemo;
```

### `ForwardRefUser.jsx` (React < 19)

```jsx
import { forwardRef } from "react";

function ForwardRefUser(props, ref) {
  return (
    <div>
      <input type="text" ref={ref} />
    </div>
  );
}

export default forwardRef(ForwardRefUser);
```

## With React 19 and above (no need to use `forwardRef`)

### example code : file: `ForwardRefUser.jsx` (React 19+)

## useFormStatus and useFormState in React

### What It Covers

- What is `useFormStatus`?
- How to use it to control form submission UI
- Full working example with custom form and async action
- When and why to use it in modern React

---

### What is `useFormStatus`?

- `useFormStatus` is a **React hook from `react-dom`** (React 18+), used inside a **form context** to check if a form submission is in progress (`pending`).
- It helps in:

  - Disabling submit buttons while the form is submitting
  - Showing loading indicators
  - Preventing duplicate submissions

  **Note**: This is especially useful in server actions or client-side transitions in frameworks like Next.js / React Router with React 18+.

---

### Example Use Case

- A login or registration form where you want to **disable the submit button** and show **"Submitting..."** while the data is being processed.

---

## 1.

### `useFormStatus` Usage

```jsx
const { pending } = useFormStatus();
```

This line extracts the pending state that becomes true while the form is submitting.

## 2. Button with Submission Feedback

```jsx
<button disabled={pending}>{pending ? "Submitting..." : "Submit"}</button>
```

This button changes its label and gets disabled during submission to prevent double-clicks or multiple submissions.

## Full Code Example : File: UseFormStatusHookDemo.jsx

---

# useTransition Hook in React

## What it Covers

- What is `useTransition`?
- Why and when to use it
- Full example using both `useState` and `useTransition`
- Comparison between state and transition-based updates

---

## What is `useTransition`?

`useTransition` is a React hook introduced in React 18 that helps you mark certain UI updates as **non-urgent** or **low priority**.

🔹 Example use cases:

- Rendering a large list or table
- Performing async updates like filtering or searching
- Preventing UI blocking during expensive re-renders

With `useTransition`, React can keep the UI **responsive** by deferring non-critical updates and showing pending indicators.

---

## Difference Between `useState` and `useTransition`

| Feature            | `useState`                 | `useTransition`          |
| ------------------ | -------------------------- | ------------------------ |
| Type of update     | Urgent / blocking          | Non-urgent / deferred    |
| UI Responsiveness  | May block UI during update | Keeps UI responsive      |
| Usage              | Immediate state change     | Schedule transition work |
| Pending Indicator? | You manage manually        | Built-in support         |

---

## Important

### 1. Basic Syntax of `useTransition`

```jsx
const [isPending, startTransition] = useTransition();
```

### 2. Start Non-Urgent Update

```jsx
startTransition(() => {
  // non-urgent logic here
});
```

## Full Example Code: UseTransitionDemo.jsx

---

# Derived State in React JS

## What it Covers

- What is **Derived State**?
- Why and when to use it
- Benefits of avoiding unnecessary state duplication
- Full demo using user list tracking

---

## What is Derived State?

Derived state refers to **calculated values** that depend on other existing `state` or `props`. Instead of storing these values as new state variables, you compute them inside the component, often using `const`.

**Do this**:

```js
const totalUsers = users.length;
```

## Avoid this:

```jsx
const [totalUsers, setTotalUsers] = useState(0); // This is redundant
```

### 1. Calculating Total Users

```jsx
const total = users.length;
```

### 2. Getting Last User

```jsx
const last = users[users.length - 1];
```

### 3. Counting Unique Users

```jsx
const unique = [...new Set(users)].length;
```

These are derived from the users array, and do not require separate useState.

## Full Code Example : DerivedDemo.jsx

---

# Lifting Up State in React JS

## What It Covers

- What is **lifting up state** in React?
- When and why to use it
- Creating **multiple components** that share data
- Complete working example with two child components

---

## What is Lifting Up State?

**Lifting state up** is the process of moving shared state from child components to their closest **common ancestor** (usually the parent component).  
Instead of maintaining local state in each component, we manage state in the parent and **pass it down via props**.

> This allows two or more child components to **communicate** and stay **in sync**.

---

## Why Lift State?

| Benefit              | Description                                       |
| -------------------- | ------------------------------------------------- |
| Shared data source   | Keeps components synced through a single source   |
| Better control       | State logic is centralized in one component       |
| Easier debugging     | Less confusion from scattered local states        |
| React best practices | Aligns with the unidirectional data flow of React |

---

## Parent: LiftUpStateDemo.jsx

## Child 1: LiftingUpAddUser.jsx

## Child 2: LiftingUpDisplayUser.jsx

---

# React Concept: Updating Object in State

## What It Covers

- How to store an object in state using `useState`
- How to **update individual object keys**
- How to **update nested object values**
- Best practices for **immutably updating** state

---

## What Does "Updating Object in State" Mean?

In React, state must be **immutable**—meaning we never directly change it.  
Instead, we **create a copy**, update it, and set the new version using `setState`.

When the state is an **object**, we use:

- The spread operator (`...`) to make shallow copies
- Separate logic to update **nested objects**

---

### Top-level Object Update

```jsx
setData((prevData) => ({
  ...prevData,
  name: "new name", // Only name is updated
}));
```

### Nested Object Update: `address.city`

```jsx
setData((prevData) => ({
  ...prevData,
  address: {
    ...prevData.address,
    city: "new city", // Only city is updated inside address
  },
}));
```

### Nested Object Update: `address.country`

```jsx
setData((prevData) => ({
  ...prevData,
  address: {
    ...prevData.address,
    country: "new country", //  Only country is updated
  },
}));
```

## Example Component: `UpdatingObjInState.jsx`

---

## Topic: Updating Arrays and Array of Objects in React State

## What it Covers

- Updating a regular array in React state
- Updating an array of objects in React state
- Using the `useState` hook
- Handling user input to update specific elements

### 1. Why Do We Need This?

In React, arrays and objects in state **should not be mutated directly**. We always create a **new copy** (using spread operator or other methods), make the changes, and then update the state.

This ensures React detects changes and re-renders the UI.

---

### 2. Regular Array Update

In the `UserList` component:

```js
const [data, setData] = useState(["John", "Jane", "Doe"]);
```

To update the last element of the array:

```js
data[data.length - 1] = newValue;
setData([...data]); // spreads into a new array
```

This updates the state correctly.

---

### 3. Array of Objects Update

In the `UserDetailsList` component:

```js
const [dataDetails, setDetails] = useState([
  { name: "John", age: 25 },
  { name: "Jane", age: 30 },
  { name: "Doe", age: 22 },
]);
```

To update the `age` of the last object:

```js
dataDetails[dataDetails.length - 1].age = newAge;
setDetails([...dataDetails]);
```

Again, you spread into a new array so React can detect the change.

## demo file: ArrayUpdateDemo.jsx

---

# useActionState Hook in React

## What It Covers

- What is `useActionState`?
- How to use `useActionState` in a form component
- Handle asynchronous form submission
- Display loading state, success, and error messages dynamically

## What is `useActionState`?

`useActionState` is a React hook used to manage stateful asynchronous actions, such as form submissions. It helps to handle pending state, success responses, and errors in a clean and declarative way.

## Why Use `useActionState`?

- Simplifies managing async form submissions
- Automatically handles loading/pending states
- Provides a clean interface for displaying success and error feedback
- Reduces boilerplate code compared to manual state management

## How It Works

- You pass a function that performs the async action (e.g., submitting form data).
- `useActionState` returns:

  - `data`: the result or error returned by your action function
  - `action`: a handler to be used as the form’s `action` prop
  - `pending`: boolean that indicates if the action is in progress

  ## Important Chunk of Code

```jsx
const handleSubmit = async (prevData, formData) => {
  let name = formData.get("name");
  let password = formData.get("password");

  await new Promise((res) => setTimeout(res, 1000));

  if (name && password) {
    return { message: "data submitted successfully", name, password };
  } else {
    return { error: "Please fill all fields" };
  }
};

const [data, action, pending] = useActionState(handleSubmit, undefined);

<form action={action}>
  <input type="text" name="name" />
  <input type="password" name="password" />
  <button disabled={pending}>{pending ? "Submitting..." : "Submit"}</button>
</form>;
```

## Example Code: `UseActionStateDemo.jsx`

---

## useId Hook in React

### What is `useId`?

`useId` is a built-in React hook introduced in **React 18**. It generates a **unique, stable ID** that is consistent across server and client, useful especially when rendering multiple components that require unique form input identifiers.

---

### Why Use `useId`?

- Prevents duplicate `id` attributes when rendering multiple instances of a component.
- Useful in forms to link `<label>` with corresponding `<input>` using `htmlFor`.
- Ensures accessibility and avoids potential DOM conflicts.

---

### How to Use `useId`

```js
const id = useId();
```

You can then use this id to generate unique element IDs like so:

```jsx

<label htmlFor={id + "-email"}>Email:</label>
<input id={id + "-email"} />
```

## Example Code: UseIDDemo.jsx

---

## React Fragment

### What it Covers

- What is a Fragment?
- Why use Fragment?
- Common issues it solves
- Code Example

---

### What is a Fragment?

A **Fragment** is a special component provided by React (`<Fragment>` or shorthand `<>`) that lets you return multiple elements **without adding extra nodes** to the DOM.

---

### Why Use Fragment?

- To **group multiple children** without introducing unnecessary wrappers like `<div>`.
- Helps **keep the DOM clean** and improves performance by avoiding unnecessary nesting.
- Useful when returning multiple elements from a component.

---

### Issues Without Fragment

- Wrapping everything inside `<div>` or other tags creates **extra DOM elements**.
- These extra elements can **break layouts** or affect CSS styling and accessibility.
- Using `<Fragment>` helps avoid this issue.

---

### Example: `FragmentDemo.jsx`

---

## Rules of React JS Hooks

React Hooks are powerful features introduced in React 16.8 that allow you to use state and other React features without writing a class component. However, there are **strict rules** to follow for Hooks to work correctly.

---

## Core Rules for Using Hooks

### 1. **Hooks must start with `use`**

All hook names **must start with** the `use` prefix.

## Correct:

```js
useState(), useEffect(), useRef(), useCustomHook();
```

## Incorrect:

```jsx
stateHook(), myEffectHook(); // These won’t work as Hooks
```

### 2. Hooks must be called at the top level

Only call Hooks at the top level of your React function. Never call them inside conditions, loops, or nested blocks.

### correct

```jsx
function MyComponent() {
  const [count, setCount] = useState(0); // ✅ Safe
}
```

### Incorrect

```jsx
if (isLoggedIn) {
  const [user, setUser] = useState(null); //   Not allowed
}
```

## What You Should Avoid

| Don't Call Hooks In...           | Reason                                                             |
| -------------------------------- | ------------------------------------------------------------------ |
| Inside conditions (`if`, `else`) | Breaks consistent hook order across renders                        |
| Inside loops (`for`, `while`)    | Each render may skip or add hook calls                             |
| After `return` statement         | The code is unreachable; hook never runs                           |
| Event handlers (`onClick`, etc.) | They are not part of the render cycle                              |
| Class components                 | Hooks only work in functional components                           |
| Try/catch/finally blocks         | Similar to conditionals — can break hook call order                |
| Regular (non-hook) functions     | Only call hooks inside React functional components or custom hooks |

---

## Custom React Hook: `useToggleHook`

## What it Covers

- What is a custom hook?
- Creating and using a `useToggleHook`
- Reusing toggle logic for multiple states
- Toggle boolean state and set explicitly to true/false

---

## What is a Custom Hook?

A **custom hook** in React is a JavaScript function whose name starts with `"use"` and that can call other hooks. It helps you **encapsulate reusable stateful logic**.

---

## Why `useToggleHook`?

Managing boolean states like show/hide or on/off is a very common pattern in React. Instead of repeating the same toggle logic using `useState`, you can simplify it with a **custom toggle hook**.

---

| **Feature**    | **Code Snippet**                                                |
| -------------- | --------------------------------------------------------------- |
| Declare Hook   | `const [value, toggleValue] = useToggleHook(true);`             |
| Toggle Logic   | `setValue(!value);`                                             |
| Set Boolean    | `if (typeof val !== "boolean") { ... } else { setValue(val); }` |
| Conditional UI | `{value ? <h3>Custom Hook Demo</h3> : null}`                    |
| Usage Pattern  | `<button onClick={() => toggleValue(true)}>Show</button>`       |

---

# React Context API Example

## What is Context API?

The **Context API** in React allows you to **share data globally** across components, without passing props manually at every level.

It is ideal for:

- Passing down themes, authentication, language, user info, etc.
- Avoiding "prop drilling" (passing data through many levels)

---

## ⚙️ How Does Context API Work?

The Context API has 3 main parts:

| Part              | Role                                                         |
| ----------------- | ------------------------------------------------------------ |
| `createContext()` | Initializes a new context                                    |
| `Provider`        | Wraps components and **provides** data via `value` prop      |
| `useContext()`    | A React hook to **consume** context data in child components |

---

## Steps to Use Context API in This Project

### Components Used:

- `MainComponent.jsx`
- `CollageComponent.jsx`
- `ClassComponent.jsx`
- `Student.jsx`
- `SubjectComponent.jsx`
- `ContextData.jsx`

---

### Step-by-Step Breakdown

#### Step 1: Create All Components

- Basic React components like `MainComponent`, `Student`, etc.

#### Step 2: Create Context

```js
// ContextData.jsx
import { createContext } from "react";
const SubjectContext = createContext("maths"); // default value: "maths"
export { SubjectContext };
```

#### Step 3: Use Provider in MainComponent

```jsx
// MainComponent.jsx
import { SubjectContext } from "./ContextData";

<SubjectContext.Provider value={subject}>
  <CollageComponent />
</SubjectContext.Provider>;
```

#### Use Context in Nested Components

```jsx
// SubjectComponent.jsx
import { useContext } from "react";
import { SubjectContext } from "./ContextData";

const subject = useContext(SubjectContext);
```

## 🔍 Important Code Chunks

| Pattern                     | Code Example                                                             |
| --------------------------- | ------------------------------------------------------------------------ |
| Create Context              | `const SubjectContext = createContext("maths");`                         |
| Wrap with Provider          | `<SubjectContext.Provider value={subject}>...</SubjectContext.Provider>` |
| Update Context Value        | `onChange={(e) => setSubject(e.target.value)}`                           |
| Access Context (useContext) | `const subject = useContext(SubjectContext);`                            |
| Reset Context               | `setSubject("")` to clear selection                                      |
| Display Selected Value      | `<h3>Selected Subject: {subject}</h3>`                                   |

---

## React Router v6.7+ Setup and Example

### What is React Router?

React Router is a standard library for routing in React. It enables navigation among views of various components in a React application, allows changing the browser URL, and keeps the UI in sync with the URL.

---

### Setup Instructions

### 1. Install React Router

Use the following command in your React project:

```bash
npm install react-router-dom

```

### 2. working with Router

#### 1. Setup Router

```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
```

#### 2. Define Navigation Links

```jsx
<Link to="/about">About</Link>
```

#### 3. Setup Routes

```jsx
<Route path="/about" element={<h2>About</h2>} />
```

#### 4. Bootstrap Navigation Buttons

```jsx
<Button as={Link} to="/about">
  About
</Button>
```

---

## What is `BrowserRouter`?

`BrowserRouter` is a component from the `react-router-dom` library that enables routing in a React application using the **HTML5 History API**.

### Purpose:

- It wraps your entire app.
- Enables clean URLs like `/about`, `/contact`.
- Reactively renders components based on the current URL.
- Updates browser history without full page reloads.

### Example:

```jsx
import { BrowserRouter } from "react-router-dom";

<BrowserRouter>{/* other routing components here */}</BrowserRouter>;
```

## What is Routes?

Routes is a container component for defining multiple routes. It replaces the older Switch component from React Router v5.

### Purpose:

- It maps the current URL to one of the child Route components.
- Only one matching Route is rendered at a time.

### Example:

```jsx
import { Routes, Route } from "react-router-dom";

<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/about" element={<About />} />
</Routes>;
```

## What is Route?

Route defines a path and the component to render when the browser's URL matches that path.

- path: the URL to match (e.g., /about)
- element: the React component to render for that route

### Example:

```jsx
<Route path="/contact" element={<Contact />} />
```

### What is Link?

**Link** is a React component used to navigate to different routes without reloading the page.

### Purpose

- Replaces traditional <a> tags.
- Works with BrowserRouter to perform SPA navigation.

```jsx
import { Link } from "react-router-dom";

<Link to="/about">About Us</Link>;
```

---

# React Router Navigation with Header/Navbar

This project demonstrates how to create a **Header/Navbar** using React and React Router (v6+). It allows users to navigate between different pages: Home, About, and Login without reloading the page (SPA behavior).

---

## React router Overview

### 1. React Router Enables SPA Navigation

- React Router allows you to build a Single Page Application (SPA).
- Navigation happens **without page reloads** using components like `BrowserRouter`, `Routes`, and `Route`.

## 2. BrowserRouter is Required at the Root

- Wrap your main app with `<BrowserRouter>` to enable routing.
- It uses the **HTML5 History API** to manage browser history.

```jsx
<BrowserRouter>
  <App />
</BrowserRouter>
```

---

## 3. Routes and Route Define Paths

`Routes` is a container for `Route`s.

Each `Route` has:

- `path` — the URL
- `element` — the component to show

```jsx
<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/about" element={<About />} />
</Routes>
```

---

## 4. Link Replaces `<a>` Tags

Use `Link` from `react-router-dom` to navigate internally.

It updates the URL **without reloading the page**.

```jsx
<Link to="/about">About</Link>
```

---

## 5. `Header.jsx` Contains Navigation Bar

- The `Header` component is shown on every page.
- It includes `Link` items for **Home**, **About**, and **Login**.

---

## 6. `MainRouter.jsx` Manages Routes and Header

- Combines all routes.
- Places the `Header` component at the top.
- Displays the appropriate page based on the current path.

---

## 7. Styling is Done in `style.css`

- Flexbox is used to align logo and links.
- Custom classes style the navigation bar and list items.

---

## 8. All Navigation is Internal

- After the **initial page load**, all route changes are handled by React.
- Server must serve `index.html` for any route (like `/about`).

---

## 9. Install React Router Before Using

```bash
npm install react-router-dom
```

---

## 10. Easy to Extend

Add new pages by:

- Creating a new component
- Adding a `<Route>` in `MainRouter.jsx`
- Adding a `<Link>` in `Header.jsx`

## Project Structure

ReactRouter/
├── Home.jsx # Home page component
├── About.jsx # About page component
├── Login.jsx # Login page component
├── Header.jsx # Navbar/Header component using <Link>
├── MainRouter.jsx # All route definitions with <Routes> and <Route>
├── style.css # Styling for the header/navbar
└── main.jsx # ReactDOM entry point using <BrowserRouter>

---

## 404 Page & Redirection in React Router

This guide explains how to handle **404 Not Found** errors and redirect users using React Router (v6+).

---

### What is a 404 Page?

- A **404 page** is shown when the user visits a route that **does not exist**.
- It helps inform users that the page is unavailable or mistyped.

---

### Steps to Handle 404 in React Router

#### 1. **Create a 404 Component**

This component will be shown when no route matches.

```jsx
function PageNotFound() {
  return (
    <div>
      <h1>Page Not Found</h1>
      <Link to="/">Go Back Home</Link>
    </div>
  );
}
```

#### 2. **Define a Catch-All Route**

Use path="/\*" to catch all unmatched paths.

```jsx
<Route path="/*" element={<PageNotFound />} />
```

#### 3. **Redirect Instead of Showing 404**

If you want to redirect to the Home page instead of showing the 404 page:

```jsx
<Route path="/*" element={<Navigate to="/" />} />
```

## demo code file :: PageNotfound/ MainPageNotFound.jsx & PageNotfound/ PageNotFound.jsx

---

## Nested Navigation with React Router

This project demonstrates how to build **nested routes** using React Router v6+. A parent route (`/collage`) contains multiple child routes like `/collage/student`, `/collage/department`, and `/collage/collageDetail`.

## Key Concepts

### 1. What is Nested Routing?

Nested routing allows one route to render **sub-routes** within itself. The child routes are displayed **inside the parent component**, not separately.

### 2. How to Define Nested Routes

In your `MainRouter.jsx`:

```jsx
<Route path="/collage" element={<Collage />}>
  <Route path="student" element={<Student />} />
  <Route path="collageDetail" element={<CollageDetails />} />
  <Route path="department" element={<Department />} />
</Route>
```

These routes will be accessible as:

- `/collage/student`
- `/collage/collageDetail`
- `/collage/department`

---

## Header Navigation

In `Header.jsx`, a new link is added:

```jsx
<Link to="/collage" className="link">
  Collage
</Link>
```

---

## Collage Page with Nested Links

In `Collage.jsx`, use `<Outlet />` and nested navigation:

```jsx
import { Link, Outlet } from "react-router-dom";
import "./style.css";

function Collage() {
  return (
    <div className="collage">
      <h2>Welcome to Collage Section</h2>
      <ul>
        <li>
          <Link to="student" className="link">
            Student
          </Link>
        </li>
        <li>
          <Link to="department" className="link">
            Department
          </Link>
        </li>
        <li>
          <Link to="collageDetail" className="link">
            Collage Detail
          </Link>
        </li>
      </ul>
      <Outlet />
    </div>
  );
}

export default Collage;
```

---

## Child Components

Each child component (e.g., `Student.jsx`) is simple:

```jsx
function Student() {
  return <h2>Student</h2>;
}
```

(Same for `CollageDetails.jsx`, `Department.jsx`)

---

## Styling (`style.css`)

```css
.collage ul {
  list-style: none;
  display: flex;
  justify-content: space-between;
  width: 300px;
}

.collage .link {
  text-decoration: none;
  font-size: 20px;
  color: black;
  padding: 10px;
}
```

---

## Test URLs

| URL                      | Result                         |
| ------------------------ | ------------------------------ |
| `/collage`               | Shows collage home page        |
| `/collage/student`       | Shows Student component        |
| `/collage/department`    | Shows Department component     |
| `/collage/collageDetail` | Shows CollageDetails component |

---

- `Route` nesting allows child routes inside parent components.
- Use `<Outlet />` in the parent to render child content.
- Keep routes organized with folders for scalability.

---

## What are Layout Routes?

A **layout route** is a parent route that wraps child routes and provides a **common layout**, such as a header, sidebar, or footer.

### Use Case

Instead of repeating the same layout (e.g., header) in every route, you define it once and nest routes inside using `<Outlet />`.

### Example

```jsx
<Route element={<Header />}>
  <Route path="/" element={<Home />} />
  <Route path="/about" element={<About />} />
  <Route path="/login" element={<Login />} />
</Route>
```

Here:

- Header contains a <Outlet />.
- All child routes (/, /about, /login) are rendered inside the layout.

## What is <Outlet />?

- The <Outlet /> component renders the matched child route inside a layout.
- Used inside layout components like Header.jsx or Collage.jsx.

```jsx
function Header() {
  return (
    <div>
      <div className="header"> ... </div>
      <Outlet /> // renders child route component here
    </div>
  );
}
```

## What is an Index Route?

An index route is a default child route that renders when the parent path matches exactly.

```jsx
<Route path="/collage" element={<Collage />}>
  <Route index element={<Student />} />
  <Route path="collageDetail" element={<CollageDetails />} />
  <Route path="department" element={<Department />} />
</Route>
```

## Explanation

- Visiting /collage (without any child path) will render the Student component.
- /collage/department renders Department, and so on.

### Layout + Index in Collage Page.

### file: Collage.jsx

```jsx

<NavLink to="" className="link">Student</NavLink>
<NavLink to="department" className="link">Department</NavLink>
<NavLink to="collageDetail" className="link">Collage Details</NavLink>
<Outlet />  // renders Student by default

```

- Clicking Collage link renders the layout (Collage) and the default index (Student).
- Nested links update the view within the same layout.

| URL                      | What You See                    |
| ------------------------ | ------------------------------- |
| `/`                      | Home (with header)              |
| `/about`                 | About page (with header)        |
| `/collage`               | Collage layout + Student        |
| `/collage/department`    | Collage layout + Department     |
| `/collage/collageDetail` | Collage layout + CollageDetails |

---

## Prefix in React Router

### What is a Prefix?

In routing, a **prefix** is a common path segment shared by multiple routes.

It helps group related routes under a single path — for example, all routes related to users (`/user/about`, `/user/login`) share the prefix `/user`.

---

### Example

```jsx
<Route element={<Header />}>
  <Route path="/" element={<Home />} />

  {/* Grouping routes under '/user' prefix */}
  <Route path="user">
    <Route path="/user/about" element={<About />} />
    <Route path="/user/login" element={<Login />} />
  </Route>
</Route>
```

- /user is the prefix path.
- /user/about and /user/login are child routes nested under /user

## Navigation Links in Header

```jsx
<Link className="link" to="/user/about">About</Link>
<Link className="link" to="/user/login">Login</Link>

```

These links point to routes prefixed with /user, matching the nested route configuration.

## Benefits of Using Prefix

- Groups related routes together (e.g., /admin/_, /user/_).
- Keeps route structure modular and clean.
- Makes layout-based routing easier when using Outlet.

---

## Dynamic Routes in React Router

### What are Dynamic Routes?

Dynamic routes allow you to capture part of the URL as a **parameter** and display different content based on that parameter.

It’s useful when you want to show **individual user details**, **product pages**, **blog posts**, etc.

---

### Example Route Setup

```jsx
<Route path="/user" element={<UserList />} />
<Route path="/user/:id" element={<UserPage />} />

```

- /user → Shows all users.
- /user/:id → Shows details of a user based on the id.

## Navigation Link in Header

```jsx
<li>
  <Link to="/user" className="link">
    Users
  </Link>
</li>
```

## User List Page

This page shows a list of users with clickable links that navigate to dynamic user details.

```jsx
<Link to={"/user/" + user.id}>{user.name}</Link>
```

- Clicking sachin will go to /user/1
- Clicking sunny will go to /user/5

## User Detail Page

This page uses useParams() to extract the id from the URL:

```jsx
const paramsData = useParams();
<h4>User id is: {paramsData.id}</h4>;
```

- Visiting /user/2 will show User id is: 2.

## Back navigation:

`` jsx

<Link to="/user">Back to home</Link>
```

---

## React Router: Optional Segments

React Router allows defining **optional segments** in routes using the `?` character. This is useful when a route may or may not include a specific part (like a parameter or a keyword).

---

### What is an Optional Segment?

An optional segment allows part of a URL path to be **optional** — meaning the route will match with or without it.

### Example Syntax

```jsx
<Route path="/user/list?" element={<UserList />} />
<Route path="/user/:id/:name?" element={<UserPage />} />
```

- **list?** — optional static segment (/user or /user/list)
- **:name?** — optional dynamic parameter (/user/1 or /user/1/sachin)

## Static Optional Segment

```jsx
<Route path="/user/list?" element={<UserList />} />
```

- /user
- /user/list
  Use case: You want to keep /user and /user/list behaving the same way.

## Dynamic Optional Segment

```jsx
<Route path="/user/:id/:name?" element={<UserPage />} />
```

- /user/2
- /user/2/ranjana

This allows /user/:id to work with or without the :name parameter.

Inside UserPage.jsx, use useParams():

```jsx
const { id, name } = useParams();
```

## Then render:

```jsx

<h4>User ID: {id}</h4>
<h4>Name: {name}</h4>

```

## Links in UserList

```jsx
<Link to={"/user/" + user.id + "/" + user.name}>{user.name}</Link>
```

This creates links like:

- /user/1/sachin
- /user/3/anil

---

# React Router: NavLink and Active Class

## What is `NavLink`?

`NavLink` is a special version of `Link` provided by React Router. It not only navigates between routes but also provides styling capabilities for the **active** route.

This is helpful to highlight the currently active page in a navigation menu (e.g., by bolding or coloring it).

---

## `Link` vs `NavLink`

| Feature        | `Link`            | `NavLink`                             |
| -------------- | ----------------- | ------------------------------------- |
| Navigation     | Yes               | Yes                                   |
| Active Styling | No                | Yes (`isActive` or `activeClassName`) |
| Use Case       | Simple navigation | Navigation + active state styling     |

---

## Applying Active Class

### Using `NavLink` with Dynamic `className`

```jsx
<NavLink
  className={({ isActive }) => (isActive ? "customActive" : "link")}
  to="/"
>
  Home
</NavLink>
```

- If this link is active, it uses customActive.
- Otherwise, it uses the regular link class.

## CSS

```css
.link {
  text-decoration: none;
  font-size: 20px;
  color: black;
}

.customActive {
  font-weight: 800;
  color: blue;
}
```

This makes the active link bold and blue.

## Usage in Header

```jsx

<NavLink to="/" className="link">Home</NavLink>
<NavLink to="/user/about" className="link">About</NavLink>
<NavLink to="/user/login" className="link">Login</NavLink>
<NavLink to="/collage" className="link">Collage</NavLink>
<NavLink to="/user" className="link">Users</NavLink>
<NavLink to="/user/list" className="link">List</NavLink>

```

---

## What is an API?

**API** stands for **Application Programming Interface**.

An API acts as a **bridge** between different software systems. It allows communication between client-side applications (like JavaScript in a browser) and backend services or databases.

---

### Why Do We Need an API?

- JavaScript (running in the browser) **cannot directly connect** to databases.
- To fetch or manipulate data from a database, we create an **API using backend languages** like:
  - Node.js
  - PHP
  - Java
  - Python

These APIs interact with the database and then provide data to the frontend.

---

### API in Multi-Platform Projects

APIs are **reusable** and used across **multiple platforms**:

| Platform    | Uses the Same API |
| ----------- | ----------------- |
| Web App     | yes               |
| Mobile App  | yes               |
| Desktop App | yes               |

This ensures consistent data everywhere.

---

## Data Format in API

The most common data format used in APIs is:

### JSON (JavaScript Object Notation)

Example response:

```json
{
  "id": 1,
  "name": "Namrata",
  "role": "Developer"
}
```

---

## Fetch API Using GET Method

---

### API Method

The most common HTTP methods used with APIs are:

- **GET**: Retrieve data (Read)
- **POST**: Send new data (Create)
- **PUT / PATCH**: Update existing data
- **DELETE**: Remove data

In this case, we’re using the **GET** method to fetch data.

---

### Test API with Thunder Client (VS Code Extension)

Before using an API in your project, you can **test** it in tools like:

- **Thunder Client** (VS Code extension)
- **Postman**
- **cURL**

Example Test:

GET **https://dummyjson.com/users**

- Response will be in **JSON** format.
- Confirm it returns expected fields like `firstName`, `lastName`, `age`, etc.

---

## Integrate API in React

1. Use `useEffect` to fetch data after component mounts.
2. Use `fetch()` to send GET request.
3. Use `useState` to store the response.

### Code Flow:

```js
useEffect(() => {
  getUserData();
}, []);

async function getUserData() {
  const url = "https://dummyjson.com/users";
  let response = await fetch(url);
  response = await response.json();
  setUserData(response.users);
}
```

### Display API Data

```jsx
{
  userData.map((user) => {
    return (
      <ul key={user.id} className="user-list">
        <li>{user.firstName}</li>
        <li>{user.lastName}</li>
        <li>{user.age}</li>
      </ul>
    );
  });
}
```

## Sample CSS Styling

```css
.user-list {
  display: flex;
  justify-content: space-around;
  border: 1px solid black;
  padding: 10px;
  margin: 10px;
}
.user-list li {
  list-style: none;
  flex-direction: column;
  margin: 10px;
}
```

---

## Install JSON Server and Create a REST API

---

### What is JSON Server?

**JSON Server** is a simple tool that lets you create a **full fake REST API** using a local `db.json` file. Perfect for prototyping, testing, or front-end development without a real backend.

- No need to write backend code.
- Supports full CRUD operations: `GET`, `POST`, `PUT`, `DELETE`.

---

## Step 1: Create a Project Folder

Create a new folder for your mock API project.

```bash
mkdir json-api-server
cd json-api-server
```

## Step 2: Create db.json File

Create a file named db.json and add the following data:

```json
{
  "users": [
    {
      "id": 1,
      "name": "John Doe",
      "email": "john@example.com"
    },
    {
      "id": 2,
      "name": "Jane Smith",
      "email": "jane@example.com"
    }
  ]
}
```

This simulates a user database.

## Step 3: Install JSON Server

Install JSON Server globally using npm:

```bash

npm install -g json-server

```

## Pass it to JSON Server CLI

```bash

npx json-server db.json

```

This will start your API server on:

**http://localhost:3000**

---

## Integrate JSON Server API and Loader in React

This guide walks you through fetching data from a **JSON Server API**, displaying it in a UI, and showing a **loader** while data is being fetched.

---

### Step 1: Make a Fetch Function

Use the `fetch()` API to call data from your local JSON server.

```js
const getUserData = async () => {
  const url = "http://localhost:3000/users";
  let response = await fetch(url);
  response = await response.json();
  setUserData(response);
  setLoading(false);
};
```

### Step 2: # 🔄 Integrate JSON Server API and Loader in React

This guide walks you through fetching data from a **JSON Server API**, displaying it in a UI, and showing a **loader** while data is being fetched.

---

## Step 1: Make a Fetch Function

Use the `fetch()` API to call data from your local JSON server.

```js
const getUserData = async () => {
  const url = "http://localhost:3000/users";
  let response = await fetch(url);
  response = await response.json();
  setUserData(response);
  setLoading(false);
};
```

## Step 3: Handle Loading State

Create a state for loading:

```JSX
const [loading, setLoading] = useState(false);

```

Trigger it before and after fetching data:

```jsx
useEffect(() => {
  setLoading(true);
  getUserData();
}, []);
```

Display a message while loading:

```jsx

{loading ? <h1>Loading...</h1> : /* show data */}

```

---

## Routes for User List and Add User UI (React + JSON Server)

This guide helps you set up routing for a **User List** and **Add User** screen using `react-router-dom` and JSON Server.

---

### Step 1: Wrap App with `BrowserRouter`

To enable routing in React, wrap your app with `<BrowserRouter>` in `main.jsx` or `index.jsx`:

```jsx
import { BrowserRouter } from "react-router-dom";
import ReactDOM from "react-dom/client";
import MainAPI from "./MainAPI";

ReactDOM.createRoot(document.getElementById("root")).render(
  <BrowserRouter>
    <MainAPI />
  </BrowserRouter>
);
```

### step 2: Make Routes

In MainAPI.jsx, define your routes:

```jsx
<Routes>
  <Route path="/" element={<JsonApiIntegrationWithLoader />} />
  <Route path="/add" element={<UserAdd />} />
</Routes>
```

### Step 3: Create Components for User List and Add User

#### User List Component

This component fetches and displays a list of users from JSON Server:

```jsx
useEffect(() => {
  setLoading(true);
  getUserData();
}, []);

async function getUserData() {
  const response = await fetch("http://localhost:3000/users");
  const data = await response.json();
  setUserData(data);
  setLoading(false);
}
```

#### User Add Component

A simple placeholder component for adding users:

```jsx
function UserAdd() {
  return (
    <div>
      <h1>Add User</h1>
    </div>
  );
}
```

### step 4: Step 4: Add Navigation Links

```jsx
<ul className="nav-list">
  <li>
    <NavLink to="/">User List</NavLink>
  </li>
  <li>
    <NavLink to="/add">User Add</NavLink>
  </li>
</ul>
```

## Code file: JsonApiIntegrationWithLoader , MainAPI.jsx, UserAdd

---

## Integrate POST Method in API (with Validation) - React + JSON Server

This document explains how to add new users to an API using the **POST method** in React and includes input **validation** before sending the request.

---

### Why Use POST Method?

The **POST** method is used to **store** or **create new user** new data\*\* (like a new user) to the server.

### Example Use Case:

- Submitting a user registration form

---

### Key Implementation Steps

### 1 Create Input Fields

```jsx
<input placeholder="Enter Name" onChange={(e) => setName(e.target.value)} />
<input placeholder="Enter Age" onChange={(e) => setAge(e.target.value)} />
<input placeholder="Enter Email" onChange={(e) => setEmail(e.target.value)} />

```

### 2 Create State for Inputs

```jsx
const [name, setName] = useState("");
const [age, setAge] = useState("");
const [email, setEmail] = useState("");
```

These states hold the input values in real time.

### 3 Add Validation Before POST

Before making the API request, check if all fields are filled:

```jsx
if (!name || !age || !email) {
  alert("Please fill in all fields.");
  return;
}
```

### 4 Send Data to JSON Server Using POST

```jsx
const response = await fetch("http://localhost:3000/users", {
  method: "POST",
  body: JSON.stringify({ name, age, email }),
  headers: {
    "Content-Type": "application/json",
  },
});
```

If the response is successful:

```jsx
if (response) {
  alert("User Created Successfully");
}
```

```jsx
if (response) {
  alert("User Created Successfully");
}
```

---

## Integrate API for DELETE Method (React + JSON Server)

This guide shows how to **delete a user** using an API in React with the `DELETE` method from JSON Server.

---

### Why DELETE Method?

The **DELETE** HTTP method is used to remove data (e.g., a user) from a server/database.

---

### Steps to Implement

### Add Delete Button to UI

Inside your user list loop, add a `Delete` button:

```jsx
<li>
  <button onClick={() => deleteUser(user.id)}>Delete</button>
</li>
```

Each button passes the specific user's **id** to the **deleteUser** function.

### 2 Create the Delete Function

Use the fetch() API with method: "DELETE":

```jsx
const deleteUser = async (id) => {
  const url = `http://localhost:3000/users/${id}`;
  let response = await fetch(url, {
    method: "DELETE",
  });
  response = await response.json();
  getUserData(); // Refresh the list after deletion
};
```

- **url** targets the user by ID

- **DELETE** method removes the user

- After deletion, **getUserData()** is called to refresh the UI

### 3 Update Table Headers

To indicate delete functionality clearly, update your list header:

```jsx
<li>Action</li>
```

---

## Edit User Details (React + JSON Server)

This guide helps you set up **edit functionality** in a React app where data is fetched from a JSON server API.

---

### Key Steps to Implement

### 1 Add Edit Button in User List

In the user listing component:

```jsx
<button onClick={() => editUser(user.id)}>Update User</button>
```

This triggers the edit function with the selected user's ID.

### 2 Navigate to Edit Page

Use **useNavigate** from **react-router** to change route:

```jsx
const navigate = useNavigate();
const editUser = (id) => {
  navigate("edit/" + id);
};
```

---

### 3 Define Route for Edit Page

In your main routing file (**MainAPI.jsx**):

```jsx
<Route path="/edit/:id" element={<UserEdit />} />
```

This enables dynamic routing for each user's edit page.

---

### 4 Create Edit Page UI

Create a new file: **UserEdit.jsx**

```jsx
function UserEdit() {
  return (
    <div style={{ textAlign: "center" }}>
      <h3>Edit User</h3>
      <input type="text" placeholder="Enter name" />
      <br />
      <br />
      <input type="text" placeholder="Enter age" />
      <br />
      <br />
      <input type="text" placeholder="Enter email" />
      <br />
      <br />
      <button>Update</button>
    </div>
  );
}
```

You now have a working input form for editing.

### file name: JsonApiIntegrationWithLoader.jsx, MainAPI.jsx, UserEdit.jsx
